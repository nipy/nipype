<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python - Pipelines and Interfaces &mdash; nipy pipeline and interfaces package</title>
    
    <link rel="stylesheet" href="../_static/nipype.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="top" title="nipy pipeline and interfaces package" href="../index.html" />
 
<meta name="keywords" content="nipype, neuroimaging, pipeline, workflow, parallel, python, neuroscience">
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-339450-7', 'nipy.org/nipype');
  ga('send', 'pageview');
</script>

  </head>
  <body role="document">
<div class="header-wrapper">
    <div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
            <a href="../index.html">
            <img src="../_static/nipype-banner-bg.png" alt="NIPY logo"  border="0" />
        <div style="margin-top: 1em;
                border-top: 1px solid #AAA;
                border-bottom: 1px solid #AAA;
                border-radius: 5px;
                padding: 3px 1em;">
            <link rel="stylesheet" href="http://www.google.com/cse/style/look/default.css" type="text/css" />
<style type="text/css">
    a.navbar {
    color: ;
    letter-spacing: .05em;
    font-weight: bold;
        }
</style>

<a class="navbar" href="../index.html">Home</a> ·
<a class="navbar" href="../quickstart.html">Quickstart</a> ·
<a class="navbar" href="../documentation.html">Documentation</a> ·
<a class="navbar" href="../about.html">Citation</a> ·
<a class="navbar" href="http://nipy.org">NiPy</a>

        </div>
    </div>
</div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<style type="text/css">
    input.gsc-input {
        border-color: #BCCDF0;
    }
    input.gsc-search-button {
        border-color: #666666;
        background-color: #CECECE;
        padding: 0;
    }
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
    div.sphinxsidebar input[type="text"] {
        width: 100%;
    }
    div.sphinxsidebar input[type="submit"] {
        width: 100%;
    }
</style>

<div class="sidebarblock">
    <div id="cse-search-form">Loading</div>

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript">
        google.load('search', '1', {language : 'en'});
        google.setOnLoadCallback(function() {
            var customSearchControl = new google.search.CustomSearchControl(
                    '010960497803984932957:u8pmqf7fdoq');

            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.enableSearchboxOnly("../searchresults.html");
            customSearchControl.draw('cse-search-form', options);
        }, true);
    </script>
</div>

  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Interface caching</a><ul>
<li><a class="reference internal" href="#interface-caching-why-and-how">Interface caching: why and how</a></li>
<li><a class="reference internal" href="#a-big-picture-view-using-the-memory-object">A big picture view: using the <code class="docutils literal"><span class="pre">Memory</span></code> object</a></li>
<li><a class="reference internal" href="#usage-patterns-working-efficiently-with-caching">Usage patterns: working efficiently with caching</a></li>
<li><a class="reference internal" href="#api-reference">API reference</a><ul>
</ul>
</li>
</ul>
</li>
</ul>

<style type="text/css">
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
</style>
<div class="sidebarblock">
    <h3>Versions</h3>

    <div class="tile">
        <table style="width: 100%;">
            <tr style="font-weight: bold;">
                <td align="left">Release</td><td align="right">Devel</td>
            </tr>
            <tr>
                <td align="left">0.11.0</td><td align="right">0.11.0</td>
            </tr>
            <tr>
                <td align="left"><a href="install.html">Download</a></td>
                <td align="right"><a href="https://github.com/nipy/nipype">Github</a></td>
            </tr>
        </table>
    </div>

    <div id="buttons">
        <div id="ohloh-use" style="margin-right: 25px; margin-top: -2px; float: left;">
            <script type="text/javascript"
                    src="https://www.openhub.net/p/480871/widgets/project_users_logo.js">
            </script>
        </div><!-- use -->
        <g:plusone size="medium" annotation="none"></g:plusone>
        <div class="clear"></div>
    </div><!-- buttons container -->
</div>


<script type="text/javascript">
    (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
</script>

<h3>Links</h3>

<ul>
    <li>Docs: <a href="http://nipy.org/nipype">Stable</a> · <a href="http://www.mit.edu/~satra/nipype-nightly/">Nightly</a></li>
    <li>Code: <a href="http://github.com/nipy/nipype">Github</a> · <a href="http://github.com/nipy/nipype/issues">Bugs-Requests</a></li>
    <li>Forum: <a href="http://neurostars.org/t/nipype">User</a> · <a href="http://projects.scipy.org/mailman/listinfo/nipy-devel">Developer</a></li>
    <li><a href="http://nipy.org/software/license/index.html"><img src="https://img.shields.io/pypi/l/nipype.svg" alt="License"></a> · <a href="http://nipy.org/about/funding.html">Funding</a></li>
    <li><a href="https://travis-ci.org/nipy/nipype"><img src="https://travis-ci.org/nipy/nipype.png?branch=master" alt="travis"></a> · <a href='https://coveralls.io/r/nipy/nipype'><img src='https://coveralls.io/repos/nipy/nipype/badge.png' alt='Coverage Status' /></a></li>
    <li><a href="https://pypi.python.org/pypi/nipype/"><img src="https://img.shields.io/pypi/dm/nipype.svg" alt="Downloads"></a> · <a href='https://pypi.python.org/pypi/nipype/'><img src='https://img.shields.io/pypi/pyversions/nipype.svg' alt='Python Versions' /></a></li>
</ul>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="interface-caching">
<span id="caching"></span><h1>Interface caching<a class="headerlink" href="#interface-caching" title="Permalink to this headline">¶</a></h1>
<p>This section details the interface-caching mechanism, exposed in the
<code class="xref py py-mod docutils literal"><span class="pre">nipype.caching</span></code> module.</p>
<div class="section" id="interface-caching-why-and-how">
<h2>Interface caching: why and how<a class="headerlink" href="#interface-caching-why-and-how" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><a class="reference internal" href="tutorial_101.html#tutorial-101"><span>Pipelines</span></a> (also called <cite>workflows</cite>) specify
processing by an execution graph. This is useful because it opens the
door to dependency checking and enable <cite>i)</cite> to minimize
recomputations, <cite>ii)</cite> to have the execution engine transparently deal
with intermediate file manipulations.</p>
<p>They however do not blend in well with arbitrary Python code, as they
must rely on their own execution engine.</p>
</li>
<li><p class="first"><a class="reference internal" href="interface_tutorial.html#interface-tutorial"><span>Interfaces</span></a> give fine control of the
execution of each step with a thin wrapper on the underlying software.
As a result that can easily be inserted in Python code.</p>
<p>However, they force the user to specify explicit input and output file
names and cannot do any caching.</p>
</li>
</ul>
<p>This is why nipype exposes an intermediate mechanism, <cite>caching</cite> that
provides transparent output file management and caching within imperative
Python code rather than a workflow.</p>
</div>
<div class="section" id="a-big-picture-view-using-the-memory-object">
<h2>A big picture view: using the <a class="reference internal" href="#nipype.caching.Memory" title="nipype.caching.Memory"><code class="xref py py-class docutils literal"><span class="pre">Memory</span></code></a> object<a class="headerlink" href="#a-big-picture-view-using-the-memory-object" title="Permalink to this headline">¶</a></h2>
<p>nipype caching relies on the <a class="reference internal" href="#nipype.caching.Memory" title="nipype.caching.Memory"><code class="xref py py-class docutils literal"><span class="pre">Memory</span></code></a> class: it creates an
execution context that is bound to a disk cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.caching</span> <span class="kn">import</span> <span class="n">Memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mem</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">(</span><span class="n">base_dir</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the caching directory is a subdirectory called <cite>nipype_mem</cite> of
the given <cite>base_dir</cite>. This is done to avoid polluting the base director.</p>
<p>In the corresponding execution context, nipype interfaces can be turned
into callables that can be used as functions using the
<a class="reference internal" href="#nipype.caching.Memory.cache" title="nipype.caching.Memory.cache"><code class="xref py py-meth docutils literal"><span class="pre">Memory.cache()</span></code></a> method. For instance if we want to run the fslMerge
command on a set of files:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.interface</span> <span class="kn">import</span> <span class="n">fsl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fsl_merge</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">fsl</span><span class="o">.</span><span class="n">Merge</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="#nipype.caching.Memory.cache" title="nipype.caching.Memory.cache"><code class="xref py py-meth docutils literal"><span class="pre">Memory.cache()</span></code></a> method takes interfaces <strong>classes</strong>,
and not instances.</p>
<p>The resulting <cite>fsl_merge</cite> object can be applied as a function to
parameters, that will form the inputs of the <cite>merge</cite> fsl commands. Those
inputs are given as keyword arguments, bearing the same name as the
name in the inputs specs of the interface. In IPython, you can also get
the argument list by using the <cite>fsl_merge?</cite> synthax to inspect the docs:</p>
<div class="highlight-python"><div class="highlight"><pre>In [10]: fsl_merge?
String Form:PipeFunc(nipype.interfaces.fsl.utils.Merge, base_dir=/home/varoquau/dev/nipype/nipype/caching/nipype_mem)
Namespace:  Interactive
File:       /home/varoquau/dev/nipype/nipype/caching/memory.py
Definition: fsl_merge(self, **kwargs)
Docstring:
Use fslmerge to concatenate images

Inputs
------

Mandatory:
dimension: dimension along which the file will be merged
in_files: None

Optional:
args: Additional parameters to the command
environ: Environment variables (default={})
ignore_exception: Print an error message instead of throwing an exception in case the interface fails to run (default=False)
merged_file: None
output_type: FSL output type

Outputs
-------
merged_file: None
Class Docstring:
...
</pre></div>
</div>
<p>Thus <cite>fsl_merge</cite> is applied to parameters as such:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">fsl_merge</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">in_files</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a.nii.gz&#39;</span><span class="p">,</span> <span class="s">&#39;b.nii.gz&#39;</span><span class="p">])</span>
<span class="go">INFO:workflow:Executing node faa7888f5955c961e5c6aa70cbd5c807 in dir: /home/varoquau/dev/nipype/nipype/caching/nipype_mem/nipype-interfaces-fsl-utils-Merge/faa7888f5955c961e5c6aa70cbd5c807</span>
<span class="go">INFO:workflow:Running: fslmerge -t /home/varoquau/dev/nipype/nipype/caching/nipype_mem/nipype-interfaces-fsl-utils-Merge/faa7888f5955c961e5c6aa70cbd5c807/a_merged.nii /home/varoquau/dev/nipype/nipype/caching/a.nii.gz /home/varoquau/dev/nipype/nipype/caching/b.nii.gz</span>
</pre></div>
</div>
<p>The results are standard nipype nodes results. In particular, they expose
an <cite>outputs</cite> attribute that carries all the outputs of the process, as
specified by the docs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span><span class="o">.</span><span class="n">outputs</span><span class="o">.</span><span class="n">merged_file</span>
<span class="go">&#39;/home/varoquau/dev/nipype/nipype/caching/nipype_mem/nipype-interfaces-fsl-utils-Merge/faa7888f5955c961e5c6aa70cbd5c807/a_merged.nii&#39;</span>
</pre></div>
</div>
<p>Finally, and most important, if the node is applied to the same input
parameters, it is not computed, and the results are reloaded from the
disk:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">fsl_merge</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">in_files</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a.nii.gz&#39;</span><span class="p">,</span> <span class="s">&#39;b.nii.gz&#39;</span><span class="p">])</span>
<span class="go">INFO:workflow:Executing node faa7888f5955c961e5c6aa70cbd5c807 in dir: /home/varoquau/dev/nipype/nipype/caching/nipype_mem/nipype-interfaces-fsl-utils-Merge/faa7888f5955c961e5c6aa70cbd5c807</span>
<span class="go">INFO:workflow:Collecting precomputed outputs</span>
</pre></div>
</div>
<p>Once the <a class="reference internal" href="#nipype.caching.Memory" title="nipype.caching.Memory"><code class="xref py py-class docutils literal"><span class="pre">Memory</span></code></a> is set up and you are applying it to data, an
important thing to keep in mind is that you are using up disk cache. It
might be useful to clean it using the methods that <a class="reference internal" href="#nipype.caching.Memory" title="nipype.caching.Memory"><code class="xref py py-class docutils literal"><span class="pre">Memory</span></code></a>
provides for this: <a class="reference internal" href="#nipype.caching.Memory.clear_previous_runs" title="nipype.caching.Memory.clear_previous_runs"><code class="xref py py-meth docutils literal"><span class="pre">Memory.clear_previous_runs()</span></code></a>,
<a class="reference internal" href="#nipype.caching.Memory.clear_runs_since" title="nipype.caching.Memory.clear_runs_since"><code class="xref py py-meth docutils literal"><span class="pre">Memory.clear_runs_since()</span></code></a>.</p>
<div class="topic">
<p class="topic-title first">Example</p>
<p>A full-blown example showing how to stage multiple operations can be
found in the <a class="reference download internal" href="../_downloads/howto_caching_example.py"><code class="xref download docutils literal"><span class="pre">caching_example.py</span></code></a> file.</p>
</div>
</div>
<div class="section" id="usage-patterns-working-efficiently-with-caching">
<h2>Usage patterns: working efficiently with caching<a class="headerlink" href="#usage-patterns-working-efficiently-with-caching" title="Permalink to this headline">¶</a></h2>
<p>The goal of the <cite>caching</cite> module is to enable writing plain Python code
rather than workflows. Use it: instead of data grabber nodes, use for
instance the <cite>glob</cite> module. To vary parameters, use <cite>for</cite> loops. To make
reusable code, write Python functions.</p>
<p>One good rule of thumb to respect is to avoid the usage of explicit
filenames apart from the outermost inputs and outputs of your
processing. The reason being that the caching mechanism of
<code class="xref py py-mod docutils literal"><span class="pre">nipy.caching</span></code> takes care of generating the unique hashes, ensuring
that, when you vary parameters, files are not overridden by the output of
different computations.</p>
<div class="topic">
<p class="topic-title first">Debuging</p>
<p>If you need to inspect the running environment of the nodes, it may
be useful to know where they were executed. With <cite>nipype.caching</cite>,
you do not control this location as it is encoded by hashes.</p>
<p>To find out where an operation has been persisted, simply look in
it&#8217;s output variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">out</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">cwd</span>
</pre></div>
</div>
</div>
<p>Finally, the more you explore different parameters, the more you risk
creating cached results that will never be reused. Keep in mind that it
may be useful to flush the cache using <a class="reference internal" href="#nipype.caching.Memory.clear_previous_runs" title="nipype.caching.Memory.clear_previous_runs"><code class="xref py py-meth docutils literal"><span class="pre">Memory.clear_previous_runs()</span></code></a>
or <a class="reference internal" href="#nipype.caching.Memory.clear_runs_since" title="nipype.caching.Memory.clear_runs_since"><code class="xref py py-meth docutils literal"><span class="pre">Memory.clear_runs_since()</span></code></a>.</p>
</div>
<div class="section" id="api-reference">
<h2>API reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h2>
<p>The main class of the <code class="xref py py-mod docutils literal"><span class="pre">nipype.caching</span></code> module is the <a class="reference internal" href="#nipype.caching.Memory" title="nipype.caching.Memory"><code class="xref py py-class docutils literal"><span class="pre">Memory</span></code></a>
class:</p>
<dl class="class">
<dt id="nipype.caching.Memory">
<em class="property">class </em><code class="descclassname">nipype.caching.</code><code class="descname">Memory</code><span class="sig-paren">(</span><em>base_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#nipype.caching.Memory" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory context to provide caching for interfaces</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>base_dir: string</strong> :</p>
<blockquote class="last">
<div><p>The directory name of the location for the caching</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
</tbody>
</table>
<dl class="method">
<dt id="nipype.caching.Memory.cache">
<code class="descname">cache</code><span class="sig-paren">(</span><em>interface</em><span class="sig-paren">)</span><a class="headerlink" href="#nipype.caching.Memory.cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a callable that caches the output of an interface</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>interface: nipype interface</strong> :</p>
<blockquote>
<div><p>The nipype interface class to be wrapped and cached</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>pipe_func: a PipeFunc callable object</strong> :</p>
<blockquote class="last">
<div><p>An object that can be used as a function to apply the
interface to arguments. Inputs of the interface are given
as keyword arguments, bearing the same name as the name
in the inputs specs of the interface.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">mkdtemp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mem</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">(</span><span class="n">mkdtemp</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.interfaces</span> <span class="kn">import</span> <span class="n">fsl</span>
</pre></div>
</div>
<p>Here we create a callable that can be used to apply an
fsl.Merge interface to files</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fsl_merge</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">fsl</span><span class="o">.</span><span class="n">Merge</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we apply it to a list of files. We need to specify the
list of input files and the dimension along which the files
should be merged.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">results</span> <span class="o">=</span> <span class="n">fsl_merge</span><span class="p">(</span><span class="n">in_files</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;a.nii&#39;</span><span class="p">,</span> <span class="s">&#39;b.nii&#39;</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="n">dimension</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span> 
</pre></div>
</div>
<p>We can retrieve the resulting file from the outputs:
&gt;&gt;&gt; results.outputs.merged_file # doctest: +SKIP
&#8216;...&#8217;</p>
</dd></dl>

<dl class="method">
<dt id="nipype.caching.Memory.clear_previous_runs">
<code class="descname">clear_previous_runs</code><span class="sig-paren">(</span><em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipype.caching.Memory.clear_previous_runs" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all the cache that where not used in the latest run of
the memory object: i.e. since the corresponding Python object
was created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>warn: boolean, optional</strong> :</p>
<blockquote class="last">
<div><p>If true, echoes warning messages for all directory
removed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nipype.caching.Memory.clear_runs_since">
<code class="descname">clear_runs_since</code><span class="sig-paren">(</span><em>day=None</em>, <em>month=None</em>, <em>year=None</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#nipype.caching.Memory.clear_runs_since" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all the cache that where not used since the given date</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>day, month, year: integers, optional</strong> :</p>
<blockquote>
<div><p>The integers specifying the latest day (in localtime) that
a node should have been accessed to be kept. If not
given, the current date is used.</p>
</div></blockquote>
<p><strong>warn: boolean, optional</strong> :</p>
<blockquote class="last">
<div><p>If true, echoes warning messages for all directory
removed</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<hr class="docutils" />
<p>Also used are the <code class="xref py py-class docutils literal"><span class="pre">PipeFunc</span></code>, callables that are returned by the
<a class="reference internal" href="#nipype.caching.Memory.cache" title="nipype.caching.Memory.cache"><code class="xref py py-meth docutils literal"><span class="pre">Memory.cache()</span></code></a> decorator:</p>
<dl class="class">
<dt id="nipype.caching.memory.PipeFunc">
<em class="property">class </em><code class="descclassname">nipype.caching.memory.</code><code class="descname">PipeFunc</code><span class="sig-paren">(</span><em>interface</em>, <em>base_dir</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipype.caching.memory.PipeFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable interface to nipype.interface objects</p>
<p>Use this to wrap nipype.interface object and call them
specifying their input with keyword arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fsl_merge</span> <span class="o">=</span> <span class="n">PipeFunc</span><span class="p">(</span><span class="n">fsl</span><span class="o">.</span><span class="n">Merge</span><span class="p">,</span> <span class="n">base_dir</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">fsl_merge</span><span class="p">(</span><span class="n">in_files</span><span class="o">=</span><span class="n">files</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal"><span class="pre">__call__</span></code>(**kwargs)</td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="nipype.caching.memory.PipeFunc.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>interface</em>, <em>base_dir</em>, <em>callback=None</em><span class="sig-paren">)</span><a class="headerlink" href="#nipype.caching.memory.PipeFunc.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>interface: a nipype interface class</strong> :</p>
<blockquote>
<div><p>The interface class to wrap</p>
</div></blockquote>
<p><strong>base_dir: a string</strong> :</p>
<blockquote>
<div><p>The directory in which the computation will be
stored</p>
</div></blockquote>
<p><strong>callback: a callable</strong> :</p>
<blockquote class="last">
<div><p>An optional callable called each time after the function
is called.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-15, Neuroimaging in Python team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
</div>

  </body>
</html>