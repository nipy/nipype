<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Neuroimaging in Python - Pipelines and Interfaces &mdash; nipy pipeline and interfaces package</title>
    
    <link rel="stylesheet" href="../../_static/nipype.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.11.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="nipy pipeline and interfaces package" href="../../index.html" />
 
<meta name="keywords" content="nipype, neuroimaging, pipeline, workflow, parallel, python, neuroscience">
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-339450-7', 'nipy.org/nipype');
  ga('send', 'pageview');
</script>

  </head>
  <body role="document">
<div class="header-wrapper">
    <div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
            <a href="../../index.html">
            <img src="../../_static/nipype-banner-bg.png" alt="NIPY logo"  border="0" />
        <div style="margin-top: 1em;
                border-top: 1px solid #AAA;
                border-bottom: 1px solid #AAA;
                border-radius: 5px;
                padding: 3px 1em;">
            <link rel="stylesheet" href="http://www.google.com/cse/style/look/default.css" type="text/css" />
<style type="text/css">
    a.navbar {
    color: ;
    letter-spacing: .05em;
    font-weight: bold;
        }
</style>

<a class="navbar" href="../../index.html">Home</a> ·
<a class="navbar" href="../../quickstart.html">Quickstart</a> ·
<a class="navbar" href="../../documentation.html">Documentation</a> ·
<a class="navbar" href="../../about.html">Citation</a> ·
<a class="navbar" href="http://nipy.org">NiPy</a>

        </div>
    </div>
</div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<style type="text/css">
    input.gsc-input {
        border-color: #BCCDF0;
    }
    input.gsc-search-button {
        border-color: #666666;
        background-color: #CECECE;
        padding: 0;
    }
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
    div.sphinxsidebar input[type="text"] {
        width: 100%;
    }
    div.sphinxsidebar input[type="submit"] {
        width: 100%;
    }
</style>

<div class="sidebarblock">
    <div id="cse-search-form">Loading</div>

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript">
        google.load('search', '1', {language : 'en'});
        google.setOnLoadCallback(function() {
            var customSearchControl = new google.search.CustomSearchControl(
                    '010960497803984932957:u8pmqf7fdoq');

            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.enableSearchboxOnly("../../searchresults.html");
            customSearchControl.draw('cse-search-form', options);
        }, true);
    </script>
</div>

  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">dMRI: Connectivity - Camino, CMTK, FreeSurfer</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
</ul>
</li>
</ul>

<style type="text/css">
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
</style>
<div class="sidebarblock">
    <h3>Versions</h3>

    <div class="tile">
        <table style="width: 100%;">
            <tr style="font-weight: bold;">
                <td align="left">Release</td><td align="right">Devel</td>
            </tr>
            <tr>
                <td align="left">0.11.0</td><td align="right">0.11.0</td>
            </tr>
            <tr>
                <td align="left"><a href="../install.html">Download</a></td>
                <td align="right"><a href="https://github.com/nipy/nipype">Github</a></td>
            </tr>
        </table>
    </div>

    <div id="buttons">
        <div id="ohloh-use" style="margin-right: 25px; margin-top: -2px; float: left;">
            <script type="text/javascript"
                    src="https://www.openhub.net/p/480871/widgets/project_users_logo.js">
            </script>
        </div><!-- use -->
        <g:plusone size="medium" annotation="none"></g:plusone>
        <div class="clear"></div>
    </div><!-- buttons container -->
</div>


<script type="text/javascript">
    (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
</script>

<h3>Links</h3>

<ul>
    <li>Docs: <a href="http://nipy.org/nipype">Stable</a> · <a href="http://www.mit.edu/~satra/nipype-nightly/">Nightly</a></li>
    <li>Code: <a href="http://github.com/nipy/nipype">Github</a> · <a href="http://github.com/nipy/nipype/issues">Bugs-Requests</a></li>
    <li>Forum: <a href="http://neurostars.org/t/nipype">User</a> · <a href="http://projects.scipy.org/mailman/listinfo/nipy-devel">Developer</a></li>
    <li><a href="http://nipy.org/software/license/index.html"><img src="https://img.shields.io/pypi/l/nipype.svg" alt="License"></a> · <a href="http://nipy.org/about/funding.html">Funding</a></li>
    <li><a href="https://travis-ci.org/nipy/nipype"><img src="https://travis-ci.org/nipy/nipype.png?branch=master" alt="travis"></a> · <a href='https://coveralls.io/r/nipy/nipype'><img src='https://coveralls.io/repos/nipy/nipype/badge.png' alt='Coverage Status' /></a></li>
    <li><a href="https://pypi.python.org/pypi/nipype/"><img src="https://img.shields.io/pypi/dm/nipype.svg" alt="Downloads"></a> · <a href='https://pypi.python.org/pypi/nipype/'><img src='https://img.shields.io/pypi/pyversions/nipype.svg' alt='Python Versions' /></a></li>
</ul>


        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dmri-connectivity-camino-cmtk-freesurfer">
<span id="example-dmri-connectivity"></span><h1>dMRI: Connectivity - Camino, CMTK, FreeSurfer<a class="headerlink" href="#dmri-connectivity-camino-cmtk-freesurfer" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This script, connectivity_tutorial.py, demonstrates the ability to perform connectivity mapping
using Nipype for pipelining, Freesurfer for Reconstruction / Parcellation, Camino for tensor-fitting
and tractography, and the Connectome Mapping Toolkit (CMTK) for connectivity analysis:</p>
<div class="highlight-python"><div class="highlight"><pre>python connectivity_tutorial.py
</pre></div>
</div>
<p>We perform this analysis using the FSL course data, which can be acquired from here:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.fmrib.ox.ac.uk/fslcourse/fsl_course_data2.tar.gz">http://www.fmrib.ox.ac.uk/fslcourse/fsl_course_data2.tar.gz</a></li>
</ul>
</div></blockquote>
<p>This pipeline also requires the Freesurfer directory for &#8216;subj1&#8217; from the FSL course data.
To save time, this data can be downloaded from here:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://dl.dropbox.com/u/315714/subj1.zip?dl=1">http://dl.dropbox.com/u/315714/subj1.zip?dl=1</a></li>
</ul>
</div></blockquote>
<p>A data package containing the outputs of this pipeline can be obtained from here:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://db.tt/1vx4vLeP">http://db.tt/1vx4vLeP</a></li>
</ul>
</div></blockquote>
<p>Along with <a class="reference external" href="http://web4.cs.ucl.ac.uk/research/medic/camino/pmwiki/pmwiki.php?n=Main.HomePage">Camino</a>,
<a class="reference external" href="http://www.nitrc.org/projects/camino-trackvis/">Camino-Trackvis</a>, <a class="reference external" href="http://www.fmrib.ox.ac.uk/fsl/">FSL</a>,
and <a class="reference external" href="http://surfer.nmr.mgh.harvard.edu/">Freesurfer</a>, you must also have the Connectome File Format
library installed as well as the Connectome Mapper.</p>
<p>These are written by Stephan Gerhard and can be obtained from:</p>
<blockquote>
<div><a class="reference external" href="http://www.cmtk.org/">http://www.cmtk.org/</a></div></blockquote>
<p>Or on github at:</p>
<blockquote>
<div>CFFlib: <a class="reference external" href="https://github.com/LTS5/cfflib">https://github.com/LTS5/cfflib</a>
CMP: <a class="reference external" href="https://github.com/LTS5/cmp">https://github.com/LTS5/cmp</a></div></blockquote>
<p>Output data can be visualized in the ConnectomeViewer</p>
<blockquote>
<div>ConnectomeViewer: <a class="reference external" href="https://github.com/LTS5/connectomeviewer">https://github.com/LTS5/connectomeviewer</a></div></blockquote>
<p>First, we import the necessary modules from nipype.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">nipype.interfaces.io</span> <span class="kn">as</span> <span class="nn">nio</span>           <span class="c"># Data i/o</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.utility</span> <span class="kn">as</span> <span class="nn">util</span>     <span class="c"># utility</span>
<span class="kn">import</span> <span class="nn">nipype.pipeline.engine</span> <span class="kn">as</span> <span class="nn">pe</span>          <span class="c"># pypeline engine</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.camino</span> <span class="kn">as</span> <span class="nn">camino</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.fsl</span> <span class="kn">as</span> <span class="nn">fsl</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.camino2trackvis</span> <span class="kn">as</span> <span class="nn">cam2trk</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.freesurfer</span> <span class="kn">as</span> <span class="nn">fs</span>    <span class="c"># freesurfer</span>
<span class="kn">import</span> <span class="nn">nipype.interfaces.cmtk</span> <span class="kn">as</span> <span class="nn">cmtk</span>
<span class="kn">import</span> <span class="nn">nipype.algorithms.misc</span> <span class="kn">as</span> <span class="nn">misc</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="kn">import</span> <span class="nn">os.path</span> <span class="kn">as</span> <span class="nn">op</span>                      <span class="c"># system functions</span>
<span class="kn">import</span> <span class="nn">cmp</span>                                    <span class="c"># connectome mapper</span>
</pre></div>
</div>
<p>We define the following functions to scrape the voxel and data dimensions of the input images. This allows the
pipeline to be flexible enough to accept and process images of varying size. The SPM Face tutorial
(fmri_spm_face.py) also implements this inferral of voxel size from the data. We also define functions to
select the proper parcellation/segregation file from Freesurfer&#8217;s output for each subject. For the mapping in
this tutorial, we use the aparc+seg.mgz file. While it is possible to change this to use the regions defined in
aparc.a2009s+aseg.mgz, one would also have to write/obtain a network resolution map defining the nodes based on those
regions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">get_vox_dims</span><span class="p">(</span><span class="n">volume</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nb</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nii</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
    <span class="n">hdr</span> <span class="o">=</span> <span class="n">nii</span><span class="o">.</span><span class="n">get_header</span><span class="p">()</span>
    <span class="n">voxdims</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">.</span><span class="n">get_zooms</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">voxdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">voxdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">voxdims</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>

<span class="k">def</span> <span class="nf">get_data_dims</span><span class="p">(</span><span class="n">volume</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nb</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">volume</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nii</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
    <span class="n">hdr</span> <span class="o">=</span> <span class="n">nii</span><span class="o">.</span><span class="n">get_header</span><span class="p">()</span>
    <span class="n">datadims</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">.</span><span class="n">get_data_shape</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">datadims</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">datadims</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">datadims</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>

<span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="n">volume</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">nibabel</span> <span class="kn">as</span> <span class="nn">nb</span>
    <span class="n">nii</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">volume</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nii</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">select_aparc</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">in_file</span> <span class="ow">in</span> <span class="n">list_of_files</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;aparc+aseg.mgz&#39;</span> <span class="ow">in</span> <span class="n">in_file</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">list_of_files</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_of_files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">select_aparc_annot</span><span class="p">(</span><span class="n">list_of_files</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">in_file</span> <span class="ow">in</span> <span class="n">list_of_files</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">&#39;.aparc.annot&#39;</span> <span class="ow">in</span> <span class="n">in_file</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">list_of_files</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">in_file</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_of_files</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
</pre></div>
</div>
<p>These need to point to the main Freesurfer directory as well as the freesurfer subjects directory.
No assumptions are made about where the directory of subjects is placed.
Recon-all must have been run on subj1 from the FSL course data.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fs_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s">&#39;/usr/local/freesurfer&#39;</span><span class="p">)</span>
<span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">curdir</span><span class="p">,</span><span class="s">&#39;./subjects&#39;</span><span class="p">))</span>
<span class="n">fsl</span><span class="o">.</span><span class="n">FSLCommand</span><span class="o">.</span><span class="n">set_default_output_type</span><span class="p">(</span><span class="s">&#39;NIFTI&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This needs to point to the fdt folder you can find after extracting
<a class="reference external" href="http://www.fmrib.ox.ac.uk/fslcourse/fsl_course_data2.tar.gz">http://www.fmrib.ox.ac.uk/fslcourse/fsl_course_data2.tar.gz</a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s">&#39;fsl_course_data/fdt/&#39;</span><span class="p">)</span>
<span class="n">fs</span><span class="o">.</span><span class="n">FSCommand</span><span class="o">.</span><span class="n">set_default_subjects_dir</span><span class="p">(</span><span class="n">subjects_dir</span><span class="p">)</span>
<span class="n">subject_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;subj1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>An infosource node is used to loop through the subject list and define the input files.
For our purposes, these are the diffusion-weighted MR image, b vectors, and b values.
The info dictionary is used to provide a template of the naming of these files. For instance,
the 4D nifti diffusion image is stored in the FSL course data as data.nii.gz.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">infosource</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">IdentityInterface</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;subject_id&#39;</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;infosource&quot;</span><span class="p">)</span>
<span class="n">infosource</span><span class="o">.</span><span class="n">iterables</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;subject_id&#39;</span><span class="p">,</span> <span class="n">subject_list</span><span class="p">)</span>

<span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dwi</span><span class="o">=</span><span class="p">[[</span><span class="s">&#39;subject_id&#39;</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">]],</span>
            <span class="n">bvecs</span><span class="o">=</span><span class="p">[[</span><span class="s">&#39;subject_id&#39;</span><span class="p">,</span><span class="s">&#39;bvecs&#39;</span><span class="p">]],</span>
            <span class="n">bvals</span><span class="o">=</span><span class="p">[[</span><span class="s">&#39;subject_id&#39;</span><span class="p">,</span><span class="s">&#39;bvals&#39;</span><span class="p">]])</span>
</pre></div>
</div>
<p>A datasource node is used to perform the actual data grabbing.
Templates for the associated images are used to obtain the correct images.
The data are assumed to lie in data_dir/subject_id/.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">datasource</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">nio</span><span class="o">.</span><span class="n">DataGrabber</span><span class="p">(</span><span class="n">infields</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;subject_id&#39;</span><span class="p">],</span>
                                               <span class="n">outfields</span><span class="o">=</span><span class="n">info</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                     <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;datasource&#39;</span><span class="p">)</span>

<span class="n">datasource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">template</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&quot;</span>
<span class="n">datasource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">base_directory</span> <span class="o">=</span> <span class="n">data_dir</span>
<span class="n">datasource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">field_template</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dwi</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">.nii.gz&#39;</span><span class="p">)</span>
<span class="n">datasource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">template_args</span> <span class="o">=</span> <span class="n">info</span>
<span class="n">datasource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">base_directory</span> <span class="o">=</span> <span class="n">data_dir</span>
<span class="n">datasource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sort_filelist</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>FreeSurferSource nodes are used to retrieve a number of image
files that were automatically generated by the recon-all process.
Here we use three of these nodes, two of which are defined to return files for solely the left and right hemispheres.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">FreeSurferSource</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">nio</span><span class="o">.</span><span class="n">FreeSurferSource</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;fssource&#39;</span><span class="p">)</span>
<span class="n">FreeSurferSource</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">subjects_dir</span>

<span class="n">FreeSurferSourceLH</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">nio</span><span class="o">.</span><span class="n">FreeSurferSource</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;fssourceLH&#39;</span><span class="p">)</span>
<span class="n">FreeSurferSourceLH</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">subjects_dir</span>
<span class="n">FreeSurferSourceLH</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">hemi</span> <span class="o">=</span> <span class="s">&#39;lh&#39;</span>

<span class="n">FreeSurferSourceRH</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">nio</span><span class="o">.</span><span class="n">FreeSurferSource</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;fssourceRH&#39;</span><span class="p">)</span>
<span class="n">FreeSurferSourceRH</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">subjects_dir</span> <span class="o">=</span> <span class="n">subjects_dir</span>
<span class="n">FreeSurferSourceRH</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">hemi</span> <span class="o">=</span> <span class="s">&#39;rh&#39;</span>
</pre></div>
</div>
<p>Since the b values and b vectors come from the FSL course, we must convert it to a scheme file
for use in Camino.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fsl2scheme</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">FSL2Scheme</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;fsl2scheme&quot;</span><span class="p">)</span>
<span class="n">fsl2scheme</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">usegradmod</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>FSL&#8217;s Brain Extraction tool is used to create a mask from the b0 image</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">b0Strip</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fsl</span><span class="o">.</span><span class="n">BET</span><span class="p">(</span><span class="n">mask</span> <span class="o">=</span> <span class="bp">True</span><span class="p">),</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;bet_b0&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>FSL&#8217;s FLIRT function is used to coregister the b0 mask and the structural image.
A convert_xfm node is then used to obtain the inverse of the transformation matrix.
FLIRT is used once again to apply the inverse transformation to the parcellated brain image.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">coregister</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fsl</span><span class="o">.</span><span class="n">FLIRT</span><span class="p">(</span><span class="n">dof</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;coregister&#39;</span><span class="p">)</span>
<span class="n">coregister</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">cost</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;corratio&#39;</span><span class="p">)</span>

<span class="n">convertxfm</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fsl</span><span class="o">.</span><span class="n">ConvertXFM</span><span class="p">(),</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;convertxfm&#39;</span><span class="p">)</span>
<span class="n">convertxfm</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">invert_xfm</span> <span class="o">=</span> <span class="bp">True</span>

<span class="n">inverse</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fsl</span><span class="o">.</span><span class="n">FLIRT</span><span class="p">(),</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;inverse&#39;</span><span class="p">)</span>
<span class="n">inverse</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">interp</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;nearestneighbour&#39;</span><span class="p">)</span>

<span class="n">inverse_AparcAseg</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fsl</span><span class="o">.</span><span class="n">FLIRT</span><span class="p">(),</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;inverse_AparcAseg&#39;</span><span class="p">)</span>
<span class="n">inverse_AparcAseg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">interp</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;nearestneighbour&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A number of conversion operations are required to obtain NIFTI files from the FreesurferSource for each subject.
Nodes are used to convert the following:</p>
<blockquote>
<div><ul>
<li><p class="first">Original structural image to NIFTI</p>
</li>
<li><p class="first">Parcellated white matter image to NIFTI</p>
</li>
<li><p class="first">Parcellated whole-brain image to NIFTI</p>
</li>
<li><dl class="first docutils">
<dt>Pial, white, inflated, and spherical surfaces for both the left and right hemispheres</dt>
<dd><p class="first last">are converted to GIFTI for visualization in ConnectomeViewer</p>
</dd>
</dl>
</li>
<li><p class="first">Parcellated annotation files for the left and right hemispheres are also converted to GIFTI</p>
</li>
</ul>
</div></blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mri_convert_Brain</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">MRIConvert</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;mri_convert_Brain&#39;</span><span class="p">)</span>
<span class="n">mri_convert_Brain</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">out_type</span> <span class="o">=</span> <span class="s">&#39;nii&#39;</span>

<span class="n">mri_convert_WMParc</span> <span class="o">=</span> <span class="n">mri_convert_Brain</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mri_convert_WMParc&#39;</span><span class="p">)</span>
<span class="n">mri_convert_AparcAseg</span> <span class="o">=</span> <span class="n">mri_convert_Brain</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mri_convert_AparcAseg&#39;</span><span class="p">)</span>

<span class="n">mris_convertLH</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">fs</span><span class="o">.</span><span class="n">MRIsConvert</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;mris_convertLH&#39;</span><span class="p">)</span>
<span class="n">mris_convertLH</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">out_datatype</span> <span class="o">=</span> <span class="s">&#39;gii&#39;</span>
<span class="n">mris_convertRH</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertRH&#39;</span><span class="p">)</span>
<span class="n">mris_convertRHwhite</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertRHwhite&#39;</span><span class="p">)</span>
<span class="n">mris_convertLHwhite</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertLHwhite&#39;</span><span class="p">)</span>
<span class="n">mris_convertRHinflated</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertRHinflated&#39;</span><span class="p">)</span>
<span class="n">mris_convertLHinflated</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertLHinflated&#39;</span><span class="p">)</span>
<span class="n">mris_convertRHsphere</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertRHsphere&#39;</span><span class="p">)</span>
<span class="n">mris_convertLHsphere</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertLHsphere&#39;</span><span class="p">)</span>
<span class="n">mris_convertLHlabels</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertLHlabels&#39;</span><span class="p">)</span>
<span class="n">mris_convertRHlabels</span> <span class="o">=</span> <span class="n">mris_convertLH</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;mris_convertRHlabels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>An inputnode is used to pass the data obtained by the data grabber to the actual processing functions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">inputnode</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">IdentityInterface</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;dwi&quot;</span><span class="p">,</span> <span class="s">&quot;bvecs&quot;</span><span class="p">,</span> <span class="s">&quot;bvals&quot;</span><span class="p">,</span> <span class="s">&quot;subject_id&quot;</span><span class="p">]),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;inputnode&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In this section we create the nodes necessary for diffusion analysis.
First, the diffusion image is converted to voxel order, since this is the format in which Camino does
its processing.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">image2voxel</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">Image2Voxel</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;image2voxel&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Second, diffusion tensors are fit to the voxel-order data.
If desired, these tensors can be converted to a Nifti tensor image using the DT2NIfTI interface.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dtifit</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">DTIFit</span><span class="p">(),</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;dtifit&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Next, a lookup table is generated from the schemefile and the
signal-to-noise ratio (SNR) of the unweighted (q=0) data.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dtlutgen</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">DTLUTGen</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;dtlutgen&quot;</span><span class="p">)</span>
<span class="n">dtlutgen</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="mf">16.0</span>
<span class="n">dtlutgen</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">inversion</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>In this tutorial we implement probabilistic tractography using the PICo algorithm.
PICo tractography requires an estimate of the fibre direction and a model of its uncertainty in each voxel;
this probabilitiy distribution map is produced using the following node.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">picopdfs</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">PicoPDFs</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;picopdfs&quot;</span><span class="p">)</span>
<span class="n">picopdfs</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">inputmodel</span> <span class="o">=</span> <span class="s">&#39;dt&#39;</span>
</pre></div>
</div>
<p>Finally, tractography is performed. In this tutorial, we will use only one iteration for time-saving purposes.
It is important to note that we use the TrackPICo interface here. This interface now expects the files required
for PICo tracking (i.e. the output from picopdfs). Similar interfaces exist for alternative types of tracking,
such as Bayesian tracking with Dirac priors (TrackBayesDirac).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">track</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">TrackPICo</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;track&quot;</span><span class="p">)</span>
<span class="n">track</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">iterations</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Currently, the best program for visualizing tracts is TrackVis. For this reason, a node is included to
convert the raw tract data to .trk format. Solely for testing purposes, another node is added to perform the reverse.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camino2trackvis</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">cam2trk</span><span class="o">.</span><span class="n">Camino2Trackvis</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;camino2trk&quot;</span><span class="p">)</span>
<span class="n">camino2trackvis</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">min_length</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">camino2trackvis</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">voxel_order</span> <span class="o">=</span> <span class="s">&#39;LAS&#39;</span>
<span class="n">trk2camino</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">cam2trk</span><span class="o">.</span><span class="n">Trackvis2Camino</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;trk2camino&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Tracts can also be converted to VTK and OOGL formats, for use in programs such as GeomView and Paraview,
using the following two nodes.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">vtkstreamlines</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">VtkStreamlines</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;vtkstreamlines&quot;</span><span class="p">)</span>
<span class="n">procstreamlines</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">ProcStreamlines</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;procstreamlines&quot;</span><span class="p">)</span>
<span class="n">procstreamlines</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">outputtracts</span> <span class="o">=</span> <span class="s">&#39;oogl&#39;</span>
</pre></div>
</div>
<p>We can easily produce a variety of scalar values from our fitted tensors. The following nodes generate the
fractional anisotropy and diffusivity trace maps and their associated headers, and then merge them back
into a single .nii file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fa</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">ComputeFractionalAnisotropy</span><span class="p">(),</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;fa&#39;</span><span class="p">)</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">ComputeTensorTrace</span><span class="p">(),</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;trace&#39;</span><span class="p">)</span>
<span class="n">dteig</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">ComputeEigensystem</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;dteig&#39;</span><span class="p">)</span>

<span class="n">analyzeheader_fa</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">AnalyzeHeader</span><span class="p">(),</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;analyzeheader_fa&#39;</span><span class="p">)</span>
<span class="n">analyzeheader_fa</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatype</span> <span class="o">=</span> <span class="s">&#39;double&#39;</span>
<span class="n">analyzeheader_trace</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">camino</span><span class="o">.</span><span class="n">AnalyzeHeader</span><span class="p">(),</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;analyzeheader_trace&#39;</span><span class="p">)</span>
<span class="n">analyzeheader_trace</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">datatype</span> <span class="o">=</span> <span class="s">&#39;double&#39;</span>

<span class="n">fa2nii</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">misc</span><span class="o">.</span><span class="n">CreateNifti</span><span class="p">(),</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;fa2nii&#39;</span><span class="p">)</span>
<span class="n">trace2nii</span> <span class="o">=</span> <span class="n">fa2nii</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&quot;trace2nii&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This section adds the Connectome Mapping Toolkit (CMTK) nodes.
These interfaces are fairly experimental and may not function properly.
In order to perform connectivity mapping using CMTK, the parcellated structural data is rewritten
using the indices and parcellation scheme from the connectome mapper (CMP). This process has been
written into the ROIGen interface, which will output a remapped aparc+aseg image as well as a
dictionary of label information (i.e. name, display colours) pertaining to the original and remapped regions.
These label values are input from a user-input lookup table, if specified, and otherwise the default
Freesurfer LUT (/freesurfer/FreeSurferColorLUT.txt).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">roigen</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">cmtk</span><span class="o">.</span><span class="n">ROIGen</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;ROIGen&quot;</span><span class="p">)</span>
<span class="n">cmp_config</span> <span class="o">=</span> <span class="nb">cmp</span><span class="o">.</span><span class="n">configuration</span><span class="o">.</span><span class="n">PipelineConfiguration</span><span class="p">(</span><span class="n">parcellation_scheme</span> <span class="o">=</span> <span class="s">&quot;NativeFreesurfer&quot;</span><span class="p">)</span>
<span class="n">cmp_config</span><span class="o">.</span><span class="n">parcellation_scheme</span> <span class="o">=</span> <span class="s">&quot;NativeFreesurfer&quot;</span>
<span class="n">roigen</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">LUT_file</span> <span class="o">=</span> <span class="n">cmp_config</span><span class="o">.</span><span class="n">get_freeview_lut</span><span class="p">(</span><span class="s">&quot;NativeFreesurfer&quot;</span><span class="p">)[</span><span class="s">&#39;freesurferaparc&#39;</span><span class="p">]</span>
<span class="n">roigen_structspace</span> <span class="o">=</span> <span class="n">roigen</span><span class="o">.</span><span class="n">clone</span><span class="p">(</span><span class="s">&#39;ROIGen_structspace&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The CreateMatrix interface takes in the remapped aparc+aseg image as well as the label dictionary and fiber tracts
and outputs a number of different files. The most important of which is the connectivity network itself, which is stored
as a &#8216;gpickle&#8217; and can be loaded using Python&#8217;s NetworkX package (see CreateMatrix docstring). Also outputted are various
NumPy arrays containing detailed tract information, such as the start and endpoint regions, and statistics on the mean and
standard deviation for the fiber length of each connection. These matrices can be used in the ConnectomeViewer to plot the
specific tracts that connect between user-selected regions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">creatematrix</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">cmtk</span><span class="o">.</span><span class="n">CreateMatrix</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;CreateMatrix&quot;</span><span class="p">)</span>
<span class="n">creatematrix</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">count_region_intersections</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">createnodes</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">cmtk</span><span class="o">.</span><span class="n">CreateNodes</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;CreateNodes&quot;</span><span class="p">)</span>
<span class="n">createnodes</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">resolution_network_file</span> <span class="o">=</span> <span class="n">cmp_config</span><span class="o">.</span><span class="n">parcellation</span><span class="p">[</span><span class="s">&#39;freesurferaparc&#39;</span><span class="p">][</span><span class="s">&#39;node_information_graphml&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Here we define the endpoint of this tutorial, which is the CFFConverter node, as well as a few nodes which use
the Nipype Merge utility. These are useful for passing lists of the files we want packaged in our CFF file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CFFConverter</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">cmtk</span><span class="o">.</span><span class="n">CFFConverter</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;CFFConverter&quot;</span><span class="p">)</span>

<span class="n">giftiSurfaces</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="mi">8</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;GiftiSurfaces&quot;</span><span class="p">)</span>
<span class="n">giftiLabels</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;GiftiLabels&quot;</span><span class="p">)</span>
<span class="n">niftiVolumes</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;NiftiVolumes&quot;</span><span class="p">)</span>
<span class="n">fiberDataArrays</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;FiberDataArrays&quot;</span><span class="p">)</span>
<span class="n">gpickledNetworks</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">interface</span><span class="o">=</span><span class="n">util</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;NetworkFiles&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we have now created all our nodes, we can define our workflow and start making connections.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Workflow</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;mapping&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>First, we connect the input node to the early conversion functions.
FreeSurfer input nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">FreeSurferSource</span><span class="p">,[(</span><span class="s">&quot;subject_id&quot;</span><span class="p">,</span><span class="s">&quot;subject_id&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">FreeSurferSourceLH</span><span class="p">,[(</span><span class="s">&quot;subject_id&quot;</span><span class="p">,</span><span class="s">&quot;subject_id&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">FreeSurferSourceRH</span><span class="p">,[(</span><span class="s">&quot;subject_id&quot;</span><span class="p">,</span><span class="s">&quot;subject_id&quot;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Required conversions for processing in Camino:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">image2voxel</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;dwi&quot;</span><span class="p">,</span> <span class="s">&quot;in_file&quot;</span><span class="p">)]),</span>
                       <span class="p">(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">fsl2scheme</span><span class="p">,</span> <span class="p">[(</span><span class="s">&quot;bvecs&quot;</span><span class="p">,</span> <span class="s">&quot;bvec_file&quot;</span><span class="p">),</span>
                                                <span class="p">(</span><span class="s">&quot;bvals&quot;</span><span class="p">,</span> <span class="s">&quot;bval_file&quot;</span><span class="p">)]),</span>
                       <span class="p">(</span><span class="n">image2voxel</span><span class="p">,</span> <span class="n">dtifit</span><span class="p">,[[</span><span class="s">&#39;voxel_order&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">]]),</span>
                       <span class="p">(</span><span class="n">fsl2scheme</span><span class="p">,</span> <span class="n">dtifit</span><span class="p">,[[</span><span class="s">&#39;scheme&#39;</span><span class="p">,</span><span class="s">&#39;scheme_file&#39;</span><span class="p">]])</span>
                      <span class="p">])</span>
</pre></div>
</div>
<p>Nifti conversions for the parcellated white matter image (used in Camino&#8217;s conmap),
and the subject&#8217;s stripped brain image from Freesurfer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSource</span><span class="p">,</span> <span class="n">mri_convert_WMParc</span><span class="p">,[(</span><span class="s">&#39;wmparc&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSource</span><span class="p">,</span> <span class="n">mri_convert_Brain</span><span class="p">,[(</span><span class="s">&#39;brain&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Surface conversions to GIFTI (pial, white, inflated, and sphere for both hemispheres)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceLH</span><span class="p">,</span> <span class="n">mris_convertLH</span><span class="p">,[(</span><span class="s">&#39;pial&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceRH</span><span class="p">,</span> <span class="n">mris_convertRH</span><span class="p">,[(</span><span class="s">&#39;pial&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceLH</span><span class="p">,</span> <span class="n">mris_convertLHwhite</span><span class="p">,[(</span><span class="s">&#39;white&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceRH</span><span class="p">,</span> <span class="n">mris_convertRHwhite</span><span class="p">,[(</span><span class="s">&#39;white&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceLH</span><span class="p">,</span> <span class="n">mris_convertLHinflated</span><span class="p">,[(</span><span class="s">&#39;inflated&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceRH</span><span class="p">,</span> <span class="n">mris_convertRHinflated</span><span class="p">,[(</span><span class="s">&#39;inflated&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceLH</span><span class="p">,</span> <span class="n">mris_convertLHsphere</span><span class="p">,[(</span><span class="s">&#39;sphere&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceRH</span><span class="p">,</span> <span class="n">mris_convertRHsphere</span><span class="p">,[(</span><span class="s">&#39;sphere&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>The annotation files are converted using the pial surface as a map via the MRIsConvert interface.
One of the functions defined earlier is used to select the lh.aparc.annot and rh.aparc.annot files
specifically (rather than i.e. rh.aparc.a2009s.annot) from the output list given by the FreeSurferSource.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceLH</span><span class="p">,</span> <span class="n">mris_convertLHlabels</span><span class="p">,[(</span><span class="s">&#39;pial&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceRH</span><span class="p">,</span> <span class="n">mris_convertRHlabels</span><span class="p">,[(</span><span class="s">&#39;pial&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceLH</span><span class="p">,</span> <span class="n">mris_convertLHlabels</span><span class="p">,</span> <span class="p">[((</span><span class="s">&#39;annot&#39;</span><span class="p">,</span> <span class="n">select_aparc_annot</span><span class="p">),</span> <span class="s">&#39;annot_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSourceRH</span><span class="p">,</span> <span class="n">mris_convertRHlabels</span><span class="p">,</span> <span class="p">[((</span><span class="s">&#39;annot&#39;</span><span class="p">,</span> <span class="n">select_aparc_annot</span><span class="p">),</span> <span class="s">&#39;annot_file&#39;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>This section coregisters the diffusion-weighted and parcellated white-matter / whole brain images.
At present the conmap node connection is left commented, as there have been recent changes in Camino
code that have presented some users with errors.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">b0Strip</span><span class="p">,[(</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">b0Strip</span><span class="p">,</span> <span class="n">coregister</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mri_convert_Brain</span><span class="p">,</span> <span class="n">coregister</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;reference&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">coregister</span><span class="p">,</span> <span class="n">convertxfm</span><span class="p">,[(</span><span class="s">&#39;out_matrix_file&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">b0Strip</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;reference&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">convertxfm</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;in_matrix_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mri_convert_WMParc</span><span class="p">,</span> <span class="n">inverse</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>The tractography pipeline consists of the following nodes. Further information about the tractography
can be found in nipype/examples/dmri_camino_dti.py.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">b0Strip</span><span class="p">,</span> <span class="n">track</span><span class="p">,[(</span><span class="s">&quot;mask_file&quot;</span><span class="p">,</span><span class="s">&quot;seed_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">fsl2scheme</span><span class="p">,</span> <span class="n">dtlutgen</span><span class="p">,[(</span><span class="s">&quot;scheme&quot;</span><span class="p">,</span><span class="s">&quot;scheme_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">dtlutgen</span><span class="p">,</span> <span class="n">picopdfs</span><span class="p">,[(</span><span class="s">&quot;dtLUT&quot;</span><span class="p">,</span><span class="s">&quot;luts&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">dtifit</span><span class="p">,</span> <span class="n">picopdfs</span><span class="p">,[(</span><span class="s">&quot;tensor_fitted&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">picopdfs</span><span class="p">,</span> <span class="n">track</span><span class="p">,[(</span><span class="s">&quot;pdfs&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Connecting the Fractional Anisotropy and Trace nodes is simple, as they obtain their input from the
tensor fitting. This is also where our voxel- and data-grabbing functions come in. We pass these functions,
along with the original DWI image from the input node, to the header-generating nodes. This ensures that the
files will be correct and readable.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">dtifit</span><span class="p">,</span> <span class="n">fa</span><span class="p">,[(</span><span class="s">&quot;tensor_fitted&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">fa</span><span class="p">,</span> <span class="n">analyzeheader_fa</span><span class="p">,[(</span><span class="s">&quot;fa&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">analyzeheader_fa</span><span class="p">,[((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_vox_dims</span><span class="p">),</span> <span class="s">&#39;voxel_dims&#39;</span><span class="p">),</span>
    <span class="p">((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_data_dims</span><span class="p">),</span> <span class="s">&#39;data_dims&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fa2nii</span><span class="p">,[(</span><span class="s">&#39;fa&#39;</span><span class="p">,</span><span class="s">&#39;data_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">fa2nii</span><span class="p">,[((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_affine</span><span class="p">),</span> <span class="s">&#39;affine&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">analyzeheader_fa</span><span class="p">,</span> <span class="n">fa2nii</span><span class="p">,[(</span><span class="s">&#39;header&#39;</span><span class="p">,</span> <span class="s">&#39;header_file&#39;</span><span class="p">)])])</span>


<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">dtifit</span><span class="p">,</span> <span class="n">trace</span><span class="p">,[(</span><span class="s">&quot;tensor_fitted&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">trace</span><span class="p">,</span> <span class="n">analyzeheader_trace</span><span class="p">,[(</span><span class="s">&quot;trace&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">analyzeheader_trace</span><span class="p">,[((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_vox_dims</span><span class="p">),</span> <span class="s">&#39;voxel_dims&#39;</span><span class="p">),</span>
    <span class="p">((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_data_dims</span><span class="p">),</span> <span class="s">&#39;data_dims&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">trace</span><span class="p">,</span> <span class="n">trace2nii</span><span class="p">,[(</span><span class="s">&#39;trace&#39;</span><span class="p">,</span><span class="s">&#39;data_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">trace2nii</span><span class="p">,[((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_affine</span><span class="p">),</span> <span class="s">&#39;affine&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">analyzeheader_trace</span><span class="p">,</span> <span class="n">trace2nii</span><span class="p">,[(</span><span class="s">&#39;header&#39;</span><span class="p">,</span> <span class="s">&#39;header_file&#39;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">dtifit</span><span class="p">,</span> <span class="n">dteig</span><span class="p">,[(</span><span class="s">&quot;tensor_fitted&quot;</span><span class="p">,</span><span class="s">&quot;in_file&quot;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>The output tracts are converted to Trackvis format (and back). Here we also use the voxel- and data-grabbing
functions defined at the beginning of the pipeline.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">track</span><span class="p">,</span> <span class="n">camino2trackvis</span><span class="p">,</span> <span class="p">[(</span><span class="s">&#39;tracked&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)]),</span>
                       <span class="p">(</span><span class="n">track</span><span class="p">,</span> <span class="n">vtkstreamlines</span><span class="p">,[[</span><span class="s">&#39;tracked&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">]]),</span>
                       <span class="p">(</span><span class="n">camino2trackvis</span><span class="p">,</span> <span class="n">trk2camino</span><span class="p">,[[</span><span class="s">&#39;trackvis&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">]])</span>
                      <span class="p">])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">camino2trackvis</span><span class="p">,[((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_vox_dims</span><span class="p">),</span> <span class="s">&#39;voxel_dims&#39;</span><span class="p">),</span>
    <span class="p">((</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span> <span class="n">get_data_dims</span><span class="p">),</span> <span class="s">&#39;data_dims&#39;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Here the CMTK connectivity mapping nodes are connected.
The original aparc+aseg image is converted to NIFTI, then registered to
the diffusion image and delivered to the ROIGen node. The remapped parcellation,
original tracts, and label file are then given to CreateMatrix.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">createnodes</span><span class="p">,</span> <span class="s">&#39;node_network&#39;</span><span class="p">,</span>
                <span class="n">creatematrix</span><span class="p">,</span> <span class="s">&#39;resolution_network_file&#39;</span><span class="p">)</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">FreeSurferSource</span><span class="p">,</span> <span class="n">mri_convert_AparcAseg</span><span class="p">,</span> <span class="p">[((</span><span class="s">&#39;aparc_aseg&#39;</span><span class="p">,</span> <span class="n">select_aparc</span><span class="p">),</span> <span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">b0Strip</span><span class="p">,</span> <span class="n">inverse_AparcAseg</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;reference&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">convertxfm</span><span class="p">,</span> <span class="n">inverse_AparcAseg</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;in_matrix_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mri_convert_AparcAseg</span><span class="p">,</span> <span class="n">inverse_AparcAseg</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;in_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mri_convert_AparcAseg</span><span class="p">,</span> <span class="n">roigen_structspace</span><span class="p">,[(</span><span class="s">&#39;out_file&#39;</span><span class="p">,</span><span class="s">&#39;aparc_aseg_file&#39;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">roigen_structspace</span><span class="p">,</span> <span class="n">createnodes</span><span class="p">,[(</span><span class="s">&quot;roi_file&quot;</span><span class="p">,</span><span class="s">&quot;roi_file&quot;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inverse_AparcAseg</span><span class="p">,</span> <span class="n">roigen</span><span class="p">,[(</span><span class="s">&quot;out_file&quot;</span><span class="p">,</span><span class="s">&quot;aparc_aseg_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">roigen</span><span class="p">,</span> <span class="n">creatematrix</span><span class="p">,[(</span><span class="s">&quot;roi_file&quot;</span><span class="p">,</span><span class="s">&quot;roi_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">camino2trackvis</span><span class="p">,</span> <span class="n">creatematrix</span><span class="p">,[(</span><span class="s">&quot;trackvis&quot;</span><span class="p">,</span><span class="s">&quot;tract_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">creatematrix</span><span class="p">,[(</span><span class="s">&quot;subject_id&quot;</span><span class="p">,</span><span class="s">&quot;out_matrix_file&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">creatematrix</span><span class="p">,[(</span><span class="s">&quot;subject_id&quot;</span><span class="p">,</span><span class="s">&quot;out_matrix_mat_file&quot;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>The merge nodes defined earlier are used here to create lists of the files which are
destined for the CFFConverter.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">creatematrix</span><span class="p">,</span> <span class="n">gpickledNetworks</span><span class="p">,[(</span><span class="s">&quot;matrix_files&quot;</span><span class="p">,</span><span class="s">&quot;in1&quot;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertLH</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in1&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertRH</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in2&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertLHwhite</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in3&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertRHwhite</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in4&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertLHinflated</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in5&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertRHinflated</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in6&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertLHsphere</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in7&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertRHsphere</span><span class="p">,</span> <span class="n">giftiSurfaces</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in8&quot;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertLHlabels</span><span class="p">,</span> <span class="n">giftiLabels</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in1&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mris_convertRHlabels</span><span class="p">,</span> <span class="n">giftiLabels</span><span class="p">,[(</span><span class="s">&quot;converted&quot;</span><span class="p">,</span><span class="s">&quot;in2&quot;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">roigen</span><span class="p">,</span> <span class="n">niftiVolumes</span><span class="p">,[(</span><span class="s">&quot;roi_file&quot;</span><span class="p">,</span><span class="s">&quot;in1&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">niftiVolumes</span><span class="p">,[(</span><span class="s">&quot;dwi&quot;</span><span class="p">,</span><span class="s">&quot;in2&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">mri_convert_Brain</span><span class="p">,</span> <span class="n">niftiVolumes</span><span class="p">,[(</span><span class="s">&quot;out_file&quot;</span><span class="p">,</span><span class="s">&quot;in3&quot;</span><span class="p">)])])</span>

<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">creatematrix</span><span class="p">,</span> <span class="n">fiberDataArrays</span><span class="p">,[(</span><span class="s">&quot;endpoint_file&quot;</span><span class="p">,</span><span class="s">&quot;in1&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">creatematrix</span><span class="p">,</span> <span class="n">fiberDataArrays</span><span class="p">,[(</span><span class="s">&quot;endpoint_file_mm&quot;</span><span class="p">,</span><span class="s">&quot;in2&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">creatematrix</span><span class="p">,</span> <span class="n">fiberDataArrays</span><span class="p">,[(</span><span class="s">&quot;fiber_length_file&quot;</span><span class="p">,</span><span class="s">&quot;in3&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">creatematrix</span><span class="p">,</span> <span class="n">fiberDataArrays</span><span class="p">,[(</span><span class="s">&quot;fiber_label_file&quot;</span><span class="p">,</span><span class="s">&quot;in4&quot;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>This block actually connects the merged lists to the CFF converter. We pass the surfaces
and volumes that are to be included, as well as the tracts and the network itself. The currently
running pipeline (dmri_connectivity.py) is also scraped and included in the CFF file. This
makes it easy for the user to examine the entire processing pathway used to generate the end
product.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CFFConverter</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">script_files</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">getfile</span><span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">currentframe</span><span class="p">()))</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">giftiSurfaces</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;out&quot;</span><span class="p">,</span><span class="s">&quot;gifti_surfaces&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">giftiLabels</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;out&quot;</span><span class="p">,</span><span class="s">&quot;gifti_labels&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">gpickledNetworks</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;out&quot;</span><span class="p">,</span><span class="s">&quot;gpickled_networks&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">niftiVolumes</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;out&quot;</span><span class="p">,</span><span class="s">&quot;nifti_volumes&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">fiberDataArrays</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;out&quot;</span><span class="p">,</span><span class="s">&quot;data_files&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">creatematrix</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;filtered_tractographies&quot;</span><span class="p">,</span><span class="s">&quot;tract_files&quot;</span><span class="p">)])])</span>
<span class="n">mapping</span><span class="o">.</span><span class="n">connect</span><span class="p">([(</span><span class="n">inputnode</span><span class="p">,</span> <span class="n">CFFConverter</span><span class="p">,[(</span><span class="s">&quot;subject_id&quot;</span><span class="p">,</span><span class="s">&quot;title&quot;</span><span class="p">)])])</span>
</pre></div>
</div>
<p>Finally, we create another higher-level workflow to connect our mapping workflow with the info and datagrabbing nodes
declared at the beginning. Our tutorial can is now extensible to any arbitrary number of subjects by simply adding
their names to the subject list and their data to the proper folders.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">connectivity</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">Workflow</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;connectivity&quot;</span><span class="p">)</span>
<span class="n">connectivity</span><span class="o">.</span><span class="n">base_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s">&#39;dmri_connectivity&#39;</span><span class="p">)</span>
<span class="n">connectivity</span><span class="o">.</span><span class="n">connect</span><span class="p">([</span>
                    <span class="p">(</span><span class="n">infosource</span><span class="p">,</span><span class="n">datasource</span><span class="p">,[(</span><span class="s">&#39;subject_id&#39;</span><span class="p">,</span> <span class="s">&#39;subject_id&#39;</span><span class="p">)]),</span>
                    <span class="p">(</span><span class="n">datasource</span><span class="p">,</span><span class="n">mapping</span><span class="p">,[(</span><span class="s">&#39;dwi&#39;</span><span class="p">,</span><span class="s">&#39;inputnode.dwi&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s">&#39;bvals&#39;</span><span class="p">,</span><span class="s">&#39;inputnode.bvals&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="s">&#39;bvecs&#39;</span><span class="p">,</span><span class="s">&#39;inputnode.bvecs&#39;</span><span class="p">)</span>
                                               <span class="p">]),</span>
        <span class="p">(</span><span class="n">infosource</span><span class="p">,</span><span class="n">mapping</span><span class="p">,[(</span><span class="s">&#39;subject_id&#39;</span><span class="p">,</span><span class="s">&#39;inputnode.subject_id&#39;</span><span class="p">)])</span>
                <span class="p">])</span>
</pre></div>
</div>
<p>The following functions run the whole workflow and produce graphs describing the processing pipeline.
By default, write_graph outputs a .dot file and a .png image, but here we set it to output the image
as a vector graphic, by passing the format=&#8217;eps&#8217; argument.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">connectivity</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="n">connectivity</span><span class="o">.</span><span class="n">write_graph</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;eps&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The output CFF file of this pipeline can be loaded in the <a class="reference external" href="http://www.cmtk.org">Connectome Viewer</a>.
After loading the network into memory it can be examined in 3D or as a connectivity matrix
using the default scripts produced by the Code Oracle.
To compare networks, one must use the MergeCNetworks interface to merge two networks into
a single CFF file. Statistics can then be run using the Network Brain Statistics (NBS) plugin
Surfaces can also be loaded along with their labels from the aparc+aseg file. The tractography
is included in the file so that region-to-region fibers can be individually plotted using the
Code Oracle.</p>
<div class="admonition-example-source-code admonition">
<p class="first admonition-title">Example source code</p>
<p class="last">You can download <a class="reference download internal" href="../../_downloads/dmri_connectivity.py"><code class="xref download docutils literal"><span class="pre">the</span> <span class="pre">full</span> <span class="pre">source</span> <span class="pre">code</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">example</span></code></a>.
This same script is also included in the Nipype source distribution under the
<code class="file docutils literal"><span class="pre">examples</span></code> directory.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2009-15, Neuroimaging in Python team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
</div>

  </body>
</html>